// Generated by CoffeeScript 1.9.2
var slice = [].slice;

(function(root, factory) {
  if (('function' === typeof define) && (define.amd != null)) {
    return define([], factory);
  } else if (typeof exports !== "undefined" && exports !== null) {
    return module.exports = factory();
  } else {
    return root.parserCombinators = factory();
  }
})(this, function() {
  var P;
  P = {};
  P.Result = function(value, rest) {
    this.value = value;
    this.rest = rest;
  };
  P.nothing = function(input) {
    return new P.Result(null, input);
  };
  P.anyChar = function(input) {
    if (input === '') {
      return;
    }
    return new P.Result(input.charAt(0), input.slice(1));
  };
  P.string = function(string) {
    var length;
    length = string.length;
    if (length === 0) {
      throw new Error('`string` must not be blank');
    } else if (length === 1) {
      return function(input) {
        if (input.charAt(0) === string) {
          return new P.Result(string, input.slice(1));
        }
      };
    } else {
      return function(input) {
        if (input.slice(0, length) === string) {
          return new P.Result(string, input.slice(length));
        }
      };
    }
  };
  P.regex = function(arg) {
    var regex;
    regex = 'string' === typeof arg ? new RegExp('^' + arg) : arg;
    return function(input) {
      var matches, result;
      matches = regex.exec(input);
      if (matches == null) {
        return;
      }
      result = matches[0];
      return new P.Result(result, input.slice(result.length));
    };
  };
  P.whitespace = P.regex('\\s*');
  P.whitespace1 = P.regex('\\s+');
  P.charset = function(charset) {
    var regex;
    regex = new RegExp('^[' + charset + ']$');
    return function(input) {
      var char;
      char = input.charAt(0);
      if (!regex.test(char)) {
        return;
      }
      return new P.Result(char, input.slice(1));
    };
  };
  P.firstChoice = function() {
    var parsers;
    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return function(input) {
      var i, length, parser, result;
      i = -1;
      length = parsers.length;
      while (++i < length) {
        parser = parsers[i];
        if ('function' !== typeof parser) {
          throw new Error("parser passed at index `" + i + "` into `firstChoice` is not of type `function` but of type `" + (typeof parser) + "`");
        }
        result = parser(input);
        if (result != null) {
          return result;
        }
      }
    };
  };
  P.longestChoice = function() {
    var parsers;
    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return function(input) {
      var bestResult, i, length, parser, result;
      i = -1;
      length = parsers.length;
      bestResult = null;
      while (++i < length) {
        parser = parsers[i];
        if ('function' !== typeof parser) {
          throw new Error("parser passed at index `" + i + "` into `longestChoice` is not of type `function` but of type `" + (typeof parser) + "`");
        }
        result = parser(input);
        if ((result != null) && ((bestResult == null) || bestResult.rest.length > result.rest.length)) {
          bestResult = result;
        }
      }
      return bestResult;
    };
  };
  P.baseMany = function(parser, end, stringResult, atLeastOneResultRequired, input) {
    var endResult, parserResult, rest, results;
    rest = input;
    results = stringResult ? '' : [];
    while (true) {
      if (end != null) {
        endResult = end(rest);
        if (endResult != null) {
          break;
        }
      }
      parserResult = parser(rest);
      if (parserResult == null) {
        break;
      }
      if (stringResult) {
        results += parserResult.value;
      } else {
        results.push(parserResult.value);
      }
      rest = parserResult.rest;
    }
    if (atLeastOneResultRequired && results.length === 0) {
      return;
    }
    return new P.Result(results, rest);
  };
  P.many = function(parser) {
    return function(input) {
      return P.baseMany(parser, null, false, false, input);
    };
  };
  P.many1 = function(parser) {
    return function(input) {
      return P.baseMany(parser, null, false, true, input);
    };
  };
  P.concatMany1 = function(parser) {
    return function(input) {
      return P.baseMany(parser, null, true, true, input);
    };
  };
  P.concatMany1Till = function(parser, end) {
    return function(input) {
      return P.baseMany(parser, end, true, true, input);
    };
  };
  P.lazy = function(fn) {
    var cached;
    cached = null;
    return function(input) {
      if (cached == null) {
        cached = fn();
      }
      return cached(input);
    };
  };
  P.Tagged = function(tag, value) {
    this.tag = tag;
    this.value = value;
  };
  P.map = function(fn, parser) {
    return function(input) {
      var result;
      result = parser(input);
      if (!result) {
        return;
      }
      return new P.Result(fn(result.value), result.rest);
    };
  };
  P.tag = function(tag, parser) {
    return function(input) {
      var result, tagged;
      result = parser(input);
      if (!result) {
        return;
      }
      tagged = new P.Tagged(tag, result.value);
      return new P.Result(tagged, result.rest);
    };
  };
  P.maybe = function(parser, returnValue) {
    if (returnValue == null) {
      returnValue = null;
    }
    return function(input) {
      var result;
      result = parser(input);
      if (result) {
        return result;
      } else {
        return new P.Result(returnValue, input);
      }
    };
  };
  P.sequence = function() {
    var parsers;
    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return function(input) {
      var i, length, parser, rest, result, values;
      i = -1;
      length = parsers.length;
      values = [];
      rest = input;
      while (++i < length) {
        parser = parsers[i];
        if ('function' !== typeof parser) {
          throw new Error("parser passed at index `" + i + "` into `sequence` is not of type `function` but of type `" + (typeof parser) + "`");
        }
        result = parser(rest);
        if (result == null) {
          return;
        }
        values.push(result.value);
        rest = result.rest;
      }
      return new P.Result(values, rest);
    };
  };
  P.pick = function() {
    var indexes, parsers;
    indexes = arguments[0], parsers = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return function(input) {
      var array, result;
      result = P.sequence.apply(P, parsers)(input);
      if (result == null) {
        return;
      }
      array = result.value;
      if (!Array.isArray(indexes)) {
        result.value = array[indexes];
      } else {
        result.value = [];
        indexes.forEach(function(i) {
          return result.value.push(array[i]);
        });
      }
      return result;
    };
  };
  P.separated1 = function(parser, separator) {
    return P.map(function(values) {
      values[1].unshift(values[0]);
      return values[1];
    }, P.sequence(parser, P.many(P.pick(1, separator, parser))));
  };
  P.separated = function(parser, separator) {
    return P.maybe(P.separated1(parser, separator), []);
  };
  P.between = function(open, parser, close) {
    return P.pick(1, open, parser, close);
  };
  P.integer = P.map(function(x) {
    return parseInt(x, 10);
  }, P.regex('-?(0|[1-9][0-9]*)'));
  P.float = P.map(parseFloat, P.regex('-?[1-9][0-9]*\.[0-9]+'));
  P.commaSeparated = function(parser) {
    return P.separated(P.string(','), parser);
  };
  P.betweenParentheses = function(parser) {
    return P.between(P.string('('), parser, P.string(')'));
  };
  return P;
});
